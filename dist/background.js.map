{
  "version": 3,
  "sources": ["../src/background.ts"],
  "sourcesContent": ["/* eslint-disable no-console */\n// src/background.ts (MV3 Service Worker, ES module)\n// Types are provided by @types/chrome. We target ES2022.\n\ntype CaptureFormat = \"jpeg\" | \"png\";\n\ninterface Plan {\n  dpr: number;\n  vw: number;\n  vh: number;\n  sw: number;\n  sh: number;\n  overlap: number;\n  step: number;\n  stops: number[];\n}\n\ninterface Tile {\n  y: number;\n  dataUrl: string;\n}\n\ninterface StartOpts {\n  format: CaptureFormat;\n  quality: number; // 0..1 (ignored for PNG)\n  saveAs: boolean;\n  hideSticky: boolean;\n}\n\nfunction sanitize(name?: string): string {\n  return (name || \"page\").replace(/[\\\\/:*?\\\"<>|]+/g, \"_\").trim().slice(0, 100) || \"page\";\n}\nfunction ts(): string { return new Date().toISOString().replace(/[:.]/g, \"-\"); }\n\nlet creatingOffscreen: Promise<void> | null = null;\nasync function ensureOffscreen(path = \"offscreen.html\"): Promise<void> {\n  const url = chrome.runtime.getURL(path);\n  try {\n    const contexts = await chrome.runtime.getContexts?.({\n      contextTypes: [\"OFFSCREEN_DOCUMENT\"],\n      documentUrls: [url]\n    });\n    if (contexts && contexts.length) return;\n  } catch {}\n  if (!creatingOffscreen) {\n    creatingOffscreen = chrome.offscreen.createDocument({\n      url: path,\n      reasons: [\"BLOBS\"],\n      justification: \"Stitch captured frames via Canvas and export to image\"\n    });\n  }\n  await creatingOffscreen;\n  creatingOffscreen = null;\n}\n\nasync function getPlan(tabId: number): Promise<Plan> {\n  const [{ result }] = await chrome.scripting.executeScript<[], Plan>({\n    target: { tabId },\n    func: () => {\n      const dpr = self.devicePixelRatio || 1;\n      const vw = innerWidth, vh = innerHeight;\n      const sw = Math.max(document.documentElement.scrollWidth, document.body?.scrollWidth || 0, vw);\n      const sh = Math.max(document.documentElement.scrollHeight, document.body?.scrollHeight || 0, vh);\n      const overlap = Math.min(64, Math.floor(vh * 0.08));\n      const step = Math.max(1, vh - overlap);\n      const stops: number[] = [];\n      for (let y = 0; y < sh; y += step) {\n        const pos = Math.min(y, sh - vh);\n        if (!stops.length || stops[stops.length - 1] !== pos) stops.push(pos);\n        if (y + vh >= sh) break;\n      }\n      return { dpr, vw, vh, sw, sh, overlap, step, stops };\n    }\n  });\n  return result;\n}\n\nasync function scrollToY(tabId: number, y: number): Promise<void> {\n  await chrome.scripting.executeScript({\n    target: { tabId },\n    func: (top: number) => { window.scrollTo(0, top); },\n    args: [y]\n  });\n}\n\nasync function toggleSticky(tabId: number, enable: boolean): Promise<void> {\n  await chrome.scripting.executeScript({\n    target: { tabId },\n    func: (on: boolean) => {\n      const id = \"__fps_hide_sticky_style__\";\n      let el = document.getElementById(id) as HTMLStyleElement | null;\n      if (on) {\n        if (el) return;\n        el = document.createElement(\"style\");\n        el.id = id;\n        el.textContent = `\n          * { scroll-behavior: auto !important; }\n          [style*=\"position:fixed\"], [style*=\"position: sticky\"],\n          :is(header,nav,aside,footer).sticky,\n          :is(.sticky,.fixed,[data-sticky]) { visibility: hidden !important; }\n        `;\n        document.documentElement.appendChild(el);\n      } else {\n        el?.remove();\n      }\n    },\n    args: [enable]\n  });\n}\n\nasync function captureVisible(windowId: number, format: CaptureFormat, quality: number): Promise<string> {\n  const opts: chrome.tabs.CaptureVisibleTabOptions =\n    format === \"png\"\n      ? { format: \"png\" }\n      : { format: \"jpeg\", quality: Math.round((quality || 0.92) * 100) };\n  return chrome.tabs.captureVisibleTab(windowId, opts);\n}\n\nfunction setBadgeProgress(percent: number): void {\n  chrome.action.setBadgeBackgroundColor({ color: \"#0b57d0\" });\n  chrome.action.setBadgeText({ text: String(percent) });\n}\n\nasync function runCapture(tabId: number, opts: StartOpts): Promise<void> {\n  const tab = await chrome.tabs.get(tabId);\n  await ensureOffscreen();\n  const plan = await getPlan(tabId);\n\n  if (opts.hideSticky) await toggleSticky(tabId, true);\n\n  const tiles: Tile[] = [];\n  for (let i = 0; i < plan.stops.length; i++) {\n    const y = plan.stops[i];\n    await scrollToY(tabId, y);\n    await new Promise(r => setTimeout(r, 120));\n    const dataUrl = await captureVisible(tab.windowId!, opts.format, opts.quality);\n    tiles.push({ y, dataUrl });\n    const pct = Math.min(99, Math.floor(((i + 1) / plan.stops.length) * 100));\n    setBadgeProgress(pct);\n  }\n\n  const stitched: string = await new Promise((resolve, reject) => {\n    const port = chrome.runtime.connect({ name: \"stitch\" });\n    const timeout = setTimeout(() => reject(new Error(\"Offscreen stitch timeout\")), 45000);\n    port.onMessage.addListener((msg: any) => {\n      if (msg?.type === \"stitched\" && msg.dataUrl) { clearTimeout(timeout); resolve(msg.dataUrl); }\n      else if (msg?.type === \"error\") { clearTimeout(timeout); reject(new Error(msg.message)); }\n    });\n    port.postMessage({\n      type: \"stitch\",\n      plan, tiles,\n      fileType: opts.format === \"png\" ? \"image/png\" : \"image/jpeg\",\n      quality: opts.quality ?? 0.92\n    });\n  });\n\n  const u = new URL(tab.url || \"https://example.com\");\n  const nameBase = sanitize(`${u.hostname}_${tab.title || \"page\"}`);\n  const ext = opts.format === \"png\" ? \"png\" : \"jpg\";\n  const filename = `${nameBase}_${ts()}.${ext}`;\n\n  await chrome.downloads.download({\n    url: stitched,\n    filename,\n    conflictAction: opts.saveAs ? \"prompt\" : \"uniquify\",\n    saveAs: !!opts.saveAs\n  });\n\n  chrome.action.setBadgeText({ text: \"\" });\n  if (opts.hideSticky) await toggleSticky(tabId, false);\n}\n\n// Listen for popup command\nchrome.runtime.onMessage.addListener((msg: any, _sender, sendResponse) => {\n  if (msg?.type === \"START_CAPTURE\" && typeof msg.tabId === \"number\") {\n    runCapture(msg.tabId, msg.opts as StartOpts)\n      .then(() => sendResponse({ ok: true }))\n      .catch(e => sendResponse({ ok: false, error: String(e) }));\n    return true; // async\n  }\n});\n"],
  "mappings": "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",
  "names": []
}
