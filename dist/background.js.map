{
  "version": 3,
  "sources": ["../src/background.ts"],
  "sourcesContent": ["/* eslint-disable no-console */\n// src/background.ts \u2014 MV3 Service Worker (ES module)\n\nimport type { CaptureFormat, Plan, Tile, StartOpts } from \"./types\";\n\n\nfunction sanitize(name?: string): string {\n    return (name || \"page\").replace(/[\\\\/:*?\"<>|]+/g, \"_\").trim().slice(0, 100) || \"page\";\n}\nfunction ts(): string {\n    return new Date().toISOString().replace(/[:.]/g, \"-\");\n}\n\nlet creatingOffscreen: Promise<void> | null = null;\nasync function ensureOffscreen(path = \"offscreen.html\"): Promise<void> {\n    const url = chrome.runtime.getURL(path);\n    try {\n        const ctxs = await chrome.runtime.getContexts?.({\n            contextTypes: [\"OFFSCREEN_DOCUMENT\"],\n            documentUrls: [url],\n        });\n        if (ctxs && ctxs.length) return;\n    } catch {\n        // older Chrome \u2014 \u043F\u0440\u043E\u0441\u0442\u043E \u0441\u043E\u0437\u0434\u0430\u0451\u043C offscreen\n    }\n    if (!creatingOffscreen) {\n        creatingOffscreen = chrome.offscreen.createDocument({\n            url: path,\n            reasons: [\"BLOBS\"], // \u043D\u0430\u043C \u043D\u0443\u0436\u0435\u043D Canvas/Blob \u0434\u043B\u044F \u0441\u043A\u043B\u0435\u0439\u043A\u0438 \u0438 \u043A\u043E\u0434\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F\n            justification: \"Stitch captured frames via Canvas and export as image\",\n        });\n    }\n    await creatingOffscreen;\n    creatingOffscreen = null;\n}\n\n/**\n * \u0412\u0440\u0435\u043C\u0435\u043D\u043D\u043E\u0435 \u0441\u043A\u0440\u044B\u0442\u0438\u0435 \u00AB\u043B\u0438\u043F\u043A\u0438\u0445\u00BB \u0448\u0430\u043F\u043E\u043A/\u0444\u0443\u0442\u0435\u0440\u043E\u0432, \u043F\u043B\u0430\u0432\u043D\u043E\u0433\u043E \u043E\u043A\u0440\u043E\u043B\u0430 \u0438 \u0442.\u043F.\n */\nasync function toggleSticky(tabId: number, enable: boolean): Promise<void> {\n    await chrome.scripting.executeScript({\n        target: { tabId },\n        func: (on: boolean) => {\n            const id = \"__fps_hide_sticky_style__\";\n            let el = document.getElementById(id) as HTMLStyleElement | null;\n            if (on) {\n                if (el) return;\n                el = document.createElement(\"style\");\n                el.id = id;\n                el.textContent = `\n          * { scroll-behavior: auto !important; }\n          [style*=\"position:fixed\"], [style*=\"position: sticky\"],\n          :is(header,nav,aside,footer).sticky,\n          :is(.sticky,.fixed,[data-sticky]) { visibility: hidden !important; }\n        `;\n                document.documentElement.appendChild(el);\n            } else {\n                el?.remove();\n            }\n        },\n        args: [enable],\n    });\n}\n\n/**\n * \u0418\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u0443\u0435\u043C \u0446\u0435\u043B\u0435\u0432\u043E\u0439 \u043E\u043A\u0440\u043E\u043B-\u043A\u043E\u043D\u0442\u0435\u0439\u043D\u0435\u0440:\n * \u2014 \u0438\u0449\u0435\u043C \u0441\u0430\u043C\u044B\u0439 \u00AB\u0432\u044B\u0441\u043E\u043A\u0438\u0439\u00BB \u044D\u043B\u0435\u043C\u0435\u043D\u0442 \u0441 overflow:auto/scroll;\n * \u2014 \u043F\u043E\u043C\u0435\u0447\u0430\u0435\u043C \u0435\u0433\u043E data-\u0430\u0442\u0440\u0438\u0431\u0443\u0442\u043E\u043C;\n * \u2014 \u043E\u0442\u043A\u043B\u044E\u0447\u0430\u0435\u043C \u043F\u043B\u0430\u0432\u043D\u044B\u0439 \u043E\u043A\u0440\u043E\u043B (\u0434\u0435\u0442\u0435\u0440\u043C\u0438\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u043A\u0430\u0434\u0440\u044B).\n */\nasync function initScrollTarget(tabId: number): Promise<void> {\n    await chrome.scripting.executeScript({\n        target: { tabId },\n        func: () => {\n            if ((window as any).__fpsScrollInited) return;\n            (window as any).__fpsScrollInited = true;\n\n            function isScrollable(el: Element) {\n                const cs = getComputedStyle(el as HTMLElement);\n                const oy = cs.overflowY;\n                return (oy === \"auto\" || oy === \"scroll\") &&\n                    (el as HTMLElement).scrollHeight > (el as HTMLElement).clientHeight;\n            }\n\n            const candidates = new Set<Element>();\n            if (document.scrollingElement) candidates.add(document.scrollingElement);\n            if (document.documentElement)  candidates.add(document.documentElement);\n            if (document.body)             candidates.add(document.body);\n            document.querySelectorAll<HTMLElement>(\"*\").forEach(el => {\n                if (isScrollable(el)) candidates.add(el);\n            });\n\n            let target: HTMLElement = (document.scrollingElement || document.documentElement || document.body) as HTMLElement;\n            let maxH = target.scrollHeight || 0;\n            candidates.forEach((el: any) => {\n                const h = el.scrollHeight || 0;\n                if (h > maxH) { maxH = h; target = el; }\n            });\n\n            target.setAttribute(\"data-fps-scroll-target\", \"1\");\n            (window as any).__fpsScrollSelector = '[data-fps-scroll-target=\"1\"]';\n\n            // \u043E\u0442\u043A\u043B\u044E\u0447\u0430\u0435\u043C \u043F\u043B\u0430\u0432\u043D\u044B\u0439 c\u043A\u0440\u043E\u043B \u0433\u043B\u043E\u0431\u0430\u043B\u044C\u043D\u043E\n            const id = \"__fps_scroll_style__\";\n            if (!document.getElementById(id)) {\n                const st = document.createElement(\"style\");\n                st.id = id;\n                st.textContent = `*{scroll-behavior:auto!important}`;\n                document.documentElement.appendChild(st);\n            }\n        },\n    });\n}\n\n/**\n * \u041F\u043B\u0430\u043D\u0438\u0440\u0443\u0435\u043C \u0448\u0430\u0433\u0438 \u043F\u0440\u043E\u043A\u0440\u0443\u0442\u043A\u0438 \u043F\u043E \u0440\u0435\u0430\u043B\u044C\u043D\u043E\u043C\u0443 \u043A\u043E\u043D\u0442\u0435\u0439\u043D\u0435\u0440\u0443\n */\nasync function getPlan(tabId: number): Promise<Plan> {\n    const [{ result }] = await chrome.scripting.executeScript<[], Plan>({\n        target: { tabId },\n        func: () => {\n            const sel = (window as any).__fpsScrollSelector || \"[data-fps-scroll-target='1']\";\n            const el = document.querySelector(sel) as HTMLElement | null;\n\n            const dpr = self.devicePixelRatio || 1;\n            const vw = innerWidth;\n            const vh = el ? el.clientHeight : innerHeight;\n            const sw = el ? el.scrollWidth : innerWidth;\n            const sh = el\n                ? el.scrollHeight\n                : Math.max(document.documentElement.scrollHeight, document.body?.scrollHeight || 0, innerHeight);\n\n            // \u043F\u0435\u0440\u0435\u043A\u0440\u044B\u0442\u0438\u0435 ~8% \u0432\u044C\u044E\u043F\u043E\u0440\u0442\u0430, \u043C\u0430\u043A\u0441\u0438\u043C\u0443\u043C 64px, \u0447\u0442\u043E\u0431\u044B \u0441\u0433\u043B\u0430\u0434\u0438\u0442\u044C \u0448\u0432\u044B/\u043B\u0438\u043F\u043A\u0438\u0435 \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B\n            const overlap = Math.min(64, Math.floor(vh * 0.08));\n            const step = Math.max(1, vh - overlap);\n\n            const stops: number[] = [];\n            for (let y = 0; y < sh; y += step) {\n                const pos = Math.min(y, sh - vh);\n                if (!stops.length || stops[stops.length - 1] !== pos) stops.push(pos);\n                if (y + vh >= sh) break;\n            }\n\n            return { dpr, vw, vh, sw, sh, overlap, step, stops };\n        },\n    });\n    if (!result) {\n        throw new Error(\"getPlan: script did not return a Plan\");\n    }\n    return result;\n\n}\n\n/**\n * \u0421\u043A\u0440\u043E\u043B\u043B\u0438\u043C \u043D\u0430\u0439\u0434\u0435\u043D\u043D\u044B\u0439 \u043A\u043E\u043D\u0442\u0435\u0439\u043D\u0435\u0440 (\u0438\u043B\u0438 window \u043A\u0430\u043A fallback) \u0438 \u0436\u0434\u0451\u043C \u0441\u0442\u0430\u0431\u0438\u043B\u044C\u043D\u043E\u0439 \u043E\u0442\u0440\u0438\u0441\u043E\u0432\u043A\u0438\n */\nasync function scrollToY(tabId: number, y: number): Promise<void> {\n    await chrome.scripting.executeScript({\n        target: { tabId },\n        func: async (top: number) => {\n            const sel = (window as any).__fpsScrollSelector || \"[data-fps-scroll-target='1']\";\n            const el = document.querySelector(sel) as HTMLElement | null;\n            if (el) {\n                el.scrollTop = top;\n            } else {\n                document.documentElement.scrollTop = top;\n                document.body && (document.body.scrollTop = top);\n                window.scrollTo(0, top);\n            }\n            // \u0414\u0430\u0434\u0438\u043C \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0435 \u0434\u043E\u0440\u0438\u0441\u043E\u0432\u0430\u0442\u044C\u0441\u044F: \u0434\u0432\u043E\u0439\u043D\u043E\u0439 rAF + \u043C\u0438\u043A\u0440\u043E\u043F\u0430\u0443\u0437a \u0434\u043B\u044F lazy-load/\u0432\u0438\u0440\u0442\u0443\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u0438\n            await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));\n            await new Promise(r => setTimeout(r, 150));\n        },\n        args: [y],\n    });\n}\n\nasync function captureVisible(windowId: number, format: CaptureFormat, quality: number): Promise<string> {\n    return chrome.tabs.captureVisibleTab(windowId, {\n        format: format === \"png\" ? \"png\" : \"jpeg\",\n        quality: format === \"png\" ? undefined : Math.round((quality || 0.92) * 100),\n    });\n\n}\n\nfunction setBadgeProgress(percent: number): void {\n    void chrome.action.setBadgeBackgroundColor({ color: \"#0b57d0\" });\n    void chrome.action.setBadgeText({ text: String(percent) });\n}\n\nasync function runCapture(tabId: number, opts: StartOpts): Promise<void> {\n    const tab = await chrome.tabs.get(tabId);\n\n    await ensureOffscreen();\n    await initScrollTarget(tabId);\n    const plan = await getPlan(tabId);\n\n    if (opts.hideSticky) await toggleSticky(tabId, true);\n\n    const tiles: Tile[] = [];\n    for (let i = 0; i < plan.stops.length; i++) {\n        const y = plan.stops[i];\n        await scrollToY(tabId, y);\n        // \u043D\u0435\u0431\u043E\u043B\u044C\u0448\u0430\u044F \u0434\u043E\u043F\u043E\u043B\u043D\u0438\u0442\u0435\u043B\u044C\u043D\u0430\u044F \u043F\u0430\u0443\u0437\u0430 \u2014 \u0438\u043D\u043E\u0433\u0434\u0430 \u043F\u043E\u043C\u043E\u0433\u0430\u0435\u0442 \u0441 \u00AB\u0434\u0435\u0440\u0433\u0430\u043D\u044C\u0435\u043C\u00BB \u043B\u044D\u0439\u0430\u0443\u0442\u0430\n        await new Promise(r => setTimeout(r, 150));\n        const dataUrl = await captureVisible(tab.windowId!, opts.format, opts.quality);\n        tiles.push({ y, dataUrl });\n        const pct = Math.min(99, Math.floor(((i + 1) / plan.stops.length) * 100));\n        setBadgeProgress(pct);\n    }\n\n    // Stitch \u0432 offscreen\n    const stitched: string = await new Promise((resolve, reject) => {\n        const port = chrome.runtime.connect({ name: \"stitch\" });\n        const timeout = setTimeout(() => reject(new Error(\"Offscreen stitch timeout\")), 45000);\n        port.onMessage.addListener((msg: any) => {\n            if (msg?.type === \"stitched\" && msg.dataUrl) { clearTimeout(timeout); resolve(msg.dataUrl); }\n            else if (msg?.type === \"error\") { clearTimeout(timeout); reject(new Error(msg.message)); }\n        });\n        port.postMessage({\n            type: \"stitch\",\n            plan,\n            tiles,\n            fileType: opts.format === \"png\" ? \"image/png\" : \"image/jpeg\",\n            quality: opts.quality ?? 0.92,\n        });\n    });\n\n    // \u0421\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435\n    const u = new URL(tab.url || \"https://example.com\");\n    const nameBase = sanitize(`${u.hostname}_${tab.title || \"page\"}`);\n    const ext = opts.format === \"png\" ? \"png\" : \"jpg\";\n    const filename = `${nameBase}_${ts()}.${ext}`;\n\n    await chrome.downloads.download({\n        url: stitched,\n        filename,\n        conflictAction: opts.saveAs ? \"prompt\" : \"uniquify\",\n        saveAs: opts.saveAs,\n    });\n\n    void  chrome.action.setBadgeText({ text: \"\" });\n    if (opts.hideSticky) await toggleSticky(tabId, false);\n}\n\n// \u0421\u043B\u0443\u0448\u0430\u0435\u043C \u043A\u043E\u043C\u0430\u043D\u0434\u0443 \u0438\u0437 popup\nchrome.runtime.onMessage.addListener((msg: any, _sender, sendResponse) => {\n    if (msg?.type === \"START_CAPTURE\" && typeof msg.tabId === \"number\") {\n        runCapture(msg.tabId, msg.opts as StartOpts)\n            .then(() => sendResponse({ ok: true }))\n            .catch(e => sendResponse({ ok: false, error: String(e) }));\n        return true; // async\n    }\n});\n"],
  "mappings": "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",
  "names": []
}
